串讲:
	
语法部分
	1.DOS命令:
		1)cd---打开目录
		2)md---mkdir---新建目录
		3)rd---rmdir---移除目录;如果目录非空,则无法移除.一旦移除,无法撤销
		4)del---删除文件
		5)dir---查看当前目录下的子文件和子目录
	2.Java简介
		1)Java之父James Gosling
	3.Java技术结构
		1)JAVASE---基础版.为一些桌面程序及应用来提供解决方案,是后两种结构的基础
		2)JAVAEE---企业版.为企业开发提供方案
		3)JAVAME---微型版.为一些小型电子设备的嵌入提供方案
	4.Java的跨平台(可移植性)
		1)基于JVM完成的.每一种操作系统都有对应的虚拟机---虚拟机不跨平台
		2)Java文件在编译完成之后会产生class文件,class文件交由虚拟机来解释执行---class文件产生之后可以在任意一个虚拟机上执行
	5.入门程序
		1)每一个Java类在编译完成之后都会产生一个class文件---class文件名和类名对应
		2)编译---javac -d 存放的路径 要编译的Java文件
		3)运行---java -cp class文件的存放目录 包名.类名
		4)一个Java文件中可以有多个类,但是只能有一个公共类
	6.环境变量
		1)为当前的操作系统指定的一些运行参数
		2)JAVA_HOME---JDK的安装路径
		3)PATH---%JAVA_HOME%\bin;
	7.关键字
		1)53个关键字,2个没有使用---goto,const
		2)所有的关键字都是小写
	8.标识符
		1)由字母、数字、_、$组成---类名或者接口名中尽量不要使用$
		2)数字不能开头
		3)不能使用关键字
		4)见名知意---Java支持中文,但是不建议使用中文
		5)大小写敏感
		6)驼峰命名法
	9.注释
		1)作用---解释说明程序,排错
		2)单行注释---//
		3)多行注释---/* */
		4)文档注释---/** */---注释文字可以利用javadoc提取形成文档
	10.计算机常量
		1)整数常量---所有整数
		2)小数常量---所有小数
		3)字符常量---用''标志起来的一个符号
		4)字符串常量---用""标志起来的多个字符
		5)布尔常量---true/false---用于表示逻辑值
		6)空常量---null
	11.变量
		1)存储数据的容器
		2)变量定义的三个要素---数据类型、变量名、数据值
		3)变量只能在当前的范围内使用
	12.数据类型及其转换
		1)数据类型---基本数据类型和引用数据类型
		2)引用类型---类、接口、数组
		3)基本类型---byte(1)、short(2)、int(4)、long(8)、float(4)、double(8)、char(2)、boolean
		4)byte的取值范围是 -128~127
		5.整数默认为int,小数默认为double
		6)long---l/L、float---f/F、double---d/D
		7)自动转换
		8)强制转换
	13.运算符
		1)算术运算符--- + - * / % ++ --
			byte/short运算完之后都会自动提升为int
			%可以运算整数和小数
			++/--在前先自增后参与运算,在后先参与运算后自增
			byte/short可以参与自增/自减运算,运算结果依然是byte/short
			/0
		2)赋值运算符--- =、+=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=、>>>=
			赋值运算符的优先级最低
			byte/short可以参与赋值运算
			除了=以外,其余的符号都要求变量先有值后运算
		3)关系运算符--- ==、!=、>、<、>=、<=、instanceof
			instancof判断对象与类的关系
		4)逻辑运算符--- &、|、!、^、&&、||
			^:两边相同则为假,两边不同则为真
			注意&&和||的短路特性
		5)位运算符--- &、|、^、<<、>>、>>>、~
			针对的是整数的补码
			^可以交换值---追尾法、加减法、异或法
			在<<或者>>的时候,实际上移动的是(当前数字 % 32)
		6)三元运算符---逻辑值?表达式1:表达式2
			两个表达式的结果类型要一致或者能够转化
	14.流程控制
		1)顺序结构---代码是从上到下从左到右依次编译运行的
		2)分支结构
			判断结构---if、if-else、if-else if
			选择结构---switch-case
				switch()的值只能是byte/short/char/int,从JDK1.7开始允许使用String
				case的顺序是否影响结果取决于case之后是否有break
		3)循环结构---while、do-while、for
			while---不确定循环的次数、循环变量的改变不规则
			for---次数已知,步长相对固定
		4)break和continue
			break---用于选择结构和循环结构中.只能终止一层结构
			continue---只能用于循环结构中,表示跳出本次一层循环,继续下次循环
	15.数组
		1)存储同一类型的多个数据的容器---大小固定
		2)动态初始化和静态初始化
		3)排序---冒泡排序、选择排序---时间复杂度O(n²)、空间复杂度O(1)
		4)查找---数组有序的前提下可以使用二分查找---时间复杂度O(logn)空间复杂度O(1)
		5)数组的反转---头尾交换
		6)数组的扩容---扩容完成之后会产生一个新的数组
	16.二维数组
		1)容器---存储的是一维数组
		2)[]的定义位置
		3)二维数组的内存结构
	17.方法
		1)目的---复用
		2)形参和实参、方法签名
		3)方法的重载
		4)方法的重写
		5)方法的递归---在方法中调用自己本身---栈溢出错误
		6)方法的传值---基本类型传递的是实际值,引用类型传递的是地址.传递之后如果地址发生改变则不影响原来的对象

面向对象
	1.面向对象与面向过程的比较
		1)面向过程注重的步骤/动作;面向对象注重的是对象
		2)面向对象是基于面向过程的
		3)面向对象适合于相对比较复杂的场景;面向过程适合于相对简单的场景
	2.类与对象的关系
		1)类是对象的概括,对象是类的具体化
		2)属性是一种特征,方法是一种行为
	3.成员变量和局部变量
						成员变量 										局部变量
		定义位置		类内方法外 										代码块中
		作用范围		整个类											当前代码块或者语句内
		生命周期		在对象创建的时候创建你,对象被回收的时候销毁		当方法或者语句执行的时候创建,方法执行完成之后释放
		内存位置		在堆中,并且在堆中自动的赋予默认值				在栈中存储,没有默认值
	4.构造方法
		1)与类同名没有返回值类型
		2)作用---创建对象
		3)每一个类都会有构造方法;如果没有手动添加构造方法,会添加默认的公共的无参构造
		4)构造方法中可以写return,用于规避不合理的数据
	5.this关键字
		1)代表当前在活动的对象的引用,可以认为是一个虚拟对象
		2)用在本类中调用本类的方法或者属性
		3)this语句---在本类的构造方法中调用本类其他形式的构造方法.this语句必须写在构造方法的首行
		4)this不能用在静态方法和静态代码块中
	6.代码块
		1)局部代码块:定义在方法中---限制变量的使用范围和生命周期,提高栈内存的利用率
		2)构造代码块:在对象创建的时候,先于构造函数执行
	7.面向对象的特征
		1)封装、继承、多态
		2)如果问到的话可以添加第四个:抽象
	8.封装
		1)体现形式:方法、属性的私有化、内部类
		2)作用:提高复用性、保证数据的合法性
	9.继承
		1)使用extends来产生继承关系
		2)类和类之间是单继承,接口和接口之间是多继承
		3)单继承和多继承的优劣性比较:多继承在代码的复用性上要优于单继承,但是单继承在方法调用的明确性上要好于多继承
		4)作用:复用性,明确方法的调用不会导致混乱
	10.多态
		1)编译时多态(方法的重载)和运行时多态(方法的重写、向上造型)
		2)运行时多态必须基于继承或者实现关系
		3)对象的多态(向上造型)和行为的多态(方法的重载、方法的重写)
		4)作用:提高代码的灵活性,能够通过声明父类对象来实现方法的统一调用
	11.权限修饰符
		1)public > protected > 默认 > private
		2)protected可以在本类中、子类中、同包类中使用---子类中使用和子类对象不是一回事---子类对象在使用的时候必须在对应的子类中
	12.super关键字
		1)在子类中使用表示父类对象的引用,可以认为是一个虚拟对象
		2)可以通过super来调用父类对子类可见的属性和方法
		3)super不能在静态方法或者静态代码块中使用
		4)super语句:在子类的构造方法中调用父类对应形式的构造方法---子类的每个构造方法中必然直接或间接有一个super语句;如果父类只提供了含参构造,要求子类中必须手动提供super语句---super语句必须放在子类构造方法的第一行
	13.static
		1)静态变量:用static修饰的变量,在类加载的时候加载到方法区中的静态区,在静态区中赋予了默认值.静态变量先于对象而存在,所以可以不通过对象而是通过类名调用.一个类的所有的对象中存储的是静态变量在静态区中的地址,所以所有的对象是共享这个静态变量---静态变量只能定义在类中,不能定义在方法或者代码块
		2)静态方法:用static修饰的方法,随着类的加载而加载到方法区中的静态区,存储在静态区中没有执行,在方法被调用的时候到栈内存中执行.静态方法也是先于对象存在,所以习惯上是通过类名来调用静态方法.静态方法可以重载,可以被继承,但是不能重写---父子类中可以存在方法签名一致的静态方法---隐藏---如果父子类中出现了方法签名一致的方法,要么都是静态(隐藏),要么都是非静态(重写)---静态方法中不能直接使用本类或者父类中的非静态方法和非静态属性
		3)静态代码块:static{}.在类第一次使用(创建对象或者调用方法)的时候执行依次---执行顺序:父类的静态 -> 子类的静态 -> 父类的构造 -> 子类的构造
		4)静态内部类
	14.final
		1)常量:定义好之后后值不可变---对于基本类型而言是实际值不可变;对于引用类型而言是地址不可变---在一个方法中定义为常量,作为参数传递到另一个方法中不一定是常量---如果属性定义为了常量,在对象创建完成之前给一次值.如果一个静态属性定义为常量,在类加载完成之前给一次值
		2)最终方法:用final修饰的方法---可以重载,可以被继承,不可以被重写
		3)最终类:不可以被继承---最终类中的方法不一定是最终方法---现阶段由于最终类不能被继承,也因此无法改变其中的方法---最终类不能产生匿名内部类的形式---最终类一定不是抽象类
	15.abstract
		1)抽象类:一定被继承,不能实例化对象,但是抽象类中有构造方法.抽象类中可以有抽象方法也可以没有抽象方法.子类继承抽象类之后必须重写抽象类中所有的抽象方法,除非这个子类也是抽象类.抽象类中可以定义实体方法(成员方法和静态方法)和属性
		2)抽象方法:可以重载,一定是被继承被重写,所以static/final/private不能修饰抽象方法.如果抽象方法是默认权限,要求父子类同包
	16.interface
		1)在JDK1.7以前只能定义抽象方法,JDK1.8及其以后允许定义实体方法
		2)接口中的方法默认是用public abstract修饰
		3)接口与接口之间是多继承
		4)类通过implements关键字来实现接口,而且是多实现---一个类可以实现多个接口---任何一个对象都可以用个接口来进行强制转换,仅限于编译不报错,但是运行时会检查是否有实现关系
		5)接口中不能定义构造方法,也不能实例化
		6)接口中可以定义属性,属性默认用public static final来修饰
	17.内部类
		1)方法内部类、成员内部类、静态内部类---匿名内部类
		2)除了静态内部类以外,其他的内部类中不允许定义静态方法和静态变量,但是允许定义静态常量
		3)除了静态内部类以外,其他内部类允许使用当前类中的一切属性和方法,而静态内部类只能使用当前类中的静态方法和静态属性
		4)方法内部类在使用当前方法中的数据的时候要,求这个数据必须是一个常量
		5)匿名内部类本质上是继承了对应的类或者是实现了对应的接口,因此任何一个接口都可以存在匿名内部类形式,除了最终类以外的类都可以存在匿名内部类形式
		6)类中定义的接口、接口定义的类和接口都默认是静态的
	18.包
		1)声明用的是package,导包用的是import
		2)一个Java文件中只能存在一个package语句,而且这唯一的package语句,必须放在Java文件的第一行
		3)*表示导入当前包下的所有的类,不包括子包下的类
		4)同包类和java.lang包下的类在使用的时候可以不用导包
		5)java.lang---核心包; java.util---工具包
	19.垃圾分代回收机制
		1)针对的是堆内存
		2)垃圾回收器在不定的某个时刻启动来回收垃圾对象.如果在回收速率比不上对象的产生速率,就会产生OutOfMemoryError.Java中的内存回收机制是自动执行的,因此不需要程序员关心内存的使用.如果一旦产生内存问题例如内存泄漏,Java程序员是无法处理的
		3)将堆内存分为了新生代和老生代.新生代划分为了伊甸园区和幸存区.对象刚创建的时候是放入伊甸园区,经过一次回收如果依然存在,则挪到幸存区;如果经过多次回收依然存在,则挪到老生代.老生代的扫描频率远远低于新生代
		4)初代回收,完全回收
	20.类加载机制
		1)加载-校验-准备-解析-初始化
		2)加载器
			启动类加载器/引导类加载器---最基本的类加载器
			扩展类加载器
			应用类加载器/系统类加载器
		3)采取双亲委派机制来加载一个类

API
	1.Object
		1)是Java中的顶级父类,任何一个对象都可以用Object对象来接住
		2)掌握方法:getClass、toString、equals---比较两个对象是否一致,默认是比较两个对象的地址,实际开发中往往会重写
	2.String
		1)代表字符串,本身是一个常量,被共享
		2)字符串在底层是以字符数组形式来储存数据
		3)了解字符串创建的对象的个数
		4)拼接多个字符串,建议使用StringBuilder
		5)了解字符串的存储机制---字符串是存在运行时常量池---JDK1.7及其以前,常量池是在方法区中,JDK1.8开始,常量池在堆内存中
	3.Pattern
		1)正则:提供一系列的规则,然后可以利用规则进行匹配、筛选
		2)要求会写简单的正则表达式即可
	4.包装类
		1)每一种基本类型都有与之对应的包装类---int(Integer)、char(Character)
		2)自动封箱:将基本类型直接赋值给对应的引用类型,底层是调用了对应类身上的valueOf方法---范围判断---整数
		3)自动拆箱:将引用类型直接赋值给对应的基本类型,底层是调用了对应对象身上的***Value方法
		4)包装类对象的哈希码是固定不变的
	5.数学类
		1)Math:最终类,构造方法是私有的,提供了大量的操作基本类型的基本运算
		2)BigDecimal:用于精确运算的类,如果需要精确运算,需要将参数以字符串形式传入
	6.日期类
		1)Date:日期---重点掌握字符串和日期格式的转换---SimpleDateFormat
		2)Calendar:仅作了解
	7.异常
		1)异常时用于反馈和处理问题的机制
		2)顶级父类是Throwable:Error和Exception
		3)Error表示错误,一旦出现无法处理---VirtualMachineError
		4)Exception表示的异常,出现可以处理
			编译时异常:编译的时候就出现,要求必须处理:要么捕获,要么抛出
			运行时异常:编译时不报错,运行的时候出现,出现之后可以处理可以不处理
		5)异常处理的三种方式:
			多个catch单个捕获单个处理
			一个catch捕获父类统一处理
			同一组异常用|隔开分组处理
		6)如果自定义一个编译时异常可以继承Exception或者是任意一个编译时异常;如果定义一个运行时异常,继承RunTimeException或者是其子类
		7)在代码中个可以随意抛出运行时异常,也可以随意捕获运行时异常;编译时异常只能在抛出之后才能捕获---在任何场景下都可以捕获Exception
		8)无论是否出现异常,finally都会执行一次
	8.集合
		1)存储多个数据的容器---大小可变
		2)顶级接口是Collection:List,Set
		3)List:列表,元素有序(保证元素的存入顺序)可重复
			ArrayList:基于数组.内存空间连续,默认初始容量是10,每次默认增加一半(底层是基于右移)线程不安全.便于查询而不便于增删
			LinkedList:基于节点,内存空间不连续,线程不安全.便于增删而不便于查询
			Vector:基于数组,内存空间连续,默认初始容量是10,每次默认增加一倍(底层基于三元运算)线程安全
			Stack:继承了Vector,遵循先进后出
		4)Set:散列集合,元素无序(大多时候不保证元素存入顺序)不可重复
			HashSet:默认容量是16,默认加载因子是0.75f,每次默认增加一倍.线程不安全---扩容机制要求掌握
		5)Queue:队列.遵循先进先出
	9.迭代器
		1)Iterator:本质上就是利用指针来遍历对象.迭代器在迭代过程中不允许增删原集合,但是可以利用迭代器本身的remove方法移除当前在迭代的元素
		2)Iterable:允许实现这个接口的类产生的对象可以被增强for循环遍历---本质上就是遍历---JDK1.5的特性之一
	10.比较器
		1)Comparator:重写compare方法指定比较规则.如果返回一个正数表示第一个参数比较大,排序的时候会自动的排到后边;如果返回负数,表示第一个参数比较小,排序的时候会自动的排在前边
		2)Comparable:如果在排序的时候没有指定比较规则,则要求要排序的元素的对应的类身上必须实现ComparableTo方法进行自然排序
	11.泛型
		1)参数化类型---ParameterizedType,JDK1.5的特性之一
		2)泛型的擦除:指的是用具体类型替换泛型的过程,发生在编译期
		3)能够看懂泛型的继承问题:? extends 类/接口---上限; ? super 类/接口---下限
	12.断言
		1)用于预测结果的
		2)assert 断言条件 : 提示信息; 如果断言成功,则继续往下运行;如果断言失败则会出现AssertionError
		3)Java中断言不是默认开启的,需要在运行的时候指定参数: -ea