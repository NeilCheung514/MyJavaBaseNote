复习:
	1.Collection---顶级接口,本质上是一个存储多个数据的容器,大小不固定
		List---列表,元素有序(保证存入顺序)可重复
			ArrayList:底层基于数组.内存空间连续.存储时对内存要求较高.默认初始容量10.每次增加一半(基于右移运算).便于查询而不便于增删
			LinkedList:链表(基于节点).内存空间不连续.随用随开辟---没有初始容量,不用考虑扩容).线程不安全.便于增删而不便于查询.
			Vector:向量---数组.内存空间连续.默认初始容量是10,默认每次增加一倍.线程安全
			Stack:栈---继承了Vector,遵循LIFO(先进后出/后进先出)

Set---散列集合
	元素不重复,不保证元素的存入顺序,不保证顺序恒久不变
	rehash操作,扩容后重新分布
	加载因子---警戒线---默认是0.75---桶的使用数量超过总的桶的数量的75%
		加载因子越小,扩容操作操作就会越频繁,同时导致内存的浪费
		加载因子过大,导致链表过长---每一个桶中的链表过长不只是会导致查询元素比较慢,也会导致增删元素比较慢
		一般在0.6~0.8之间,0.75是一个相对合理的值
	HashSet---线程不安全
		存储机制:底层是用的一个数组来存储的数据,这个数组的默认大小是16.数组的每一个位置称为一个桶(bucket),每一个桶维系了一个链式栈结构.存放元素的时候会先计算元素的哈希码,然后将哈希码进行二次运算,根据运算的结果放入对应的桶中.如果某个元素要存放的桶中已经有了元素,会先拿这个元素和桶中的元素依次比较,如果每一个比较都不相等则会插到这个链表的首位.根据加载因子的值确定桶的使用数量,加载因子的默认值是0.75f,当使用的桶的数量超过了(总数量 * 加载因子)的值的时候,则会发生扩容操作,而每次默认增加一倍.扩容之后,原来的所有的元素都要进行重新分布的操作(rehash).
		如果初始容量比较小,则在初期会频繁发生扩容和rehash操作;如果初始容量过大会导致内存的浪费.
		如果加载因子较小会导致扩容和rehash操作频繁发生,同时也会导致内存的大量的浪费.如果加载因子过大,会导致每个桶中的链表的长度过长,而链表的长度过长会导致查询以及增删操作的效率都会降低.如果加载因子为1,则意味着HashSet不会扩容.

Queue---队列
	FIFO(先进先出)

Iterator---迭代器---取代了Enumerator
	本质上是通过指针的挪动来获取每一个元素.在遍历的时候会先复制原集合,然后依次给每一个元素一个标记,如果这个元素被移除,则标记为false,反之标记为true,在遍历完成之后,会去比对原集合,如果标记为false,则将该元素从原集合中移除---在迭代过程中,不允许直接增删原集合中的元素.

Iterable---允许实现这个接口的类的对象能够被增强for循环进行遍历---增强for循环的遍历过程实际上是迭代遍历的过程---增强for循环是JDK1.5的特性之一

Collections
	是操作集合的工具类---提供了大量的操作集合的静态方法

Comparator
	比较器---需要重写compare方法,在compare方法中指定比较规则,然后根据返回值正负来确定两个参数的大小.如果返回了一个正数,说明第一个参数比较大,应该排在后边;如果返回一个负数,说明第一个参数比较小,应该排在前边
	在排序的时候如果没有指定比较规则,要求集合中的元素实现Comparable

泛型
	参数化类型---ParameterizedType---JDK1.5的特性之一
	List list = new ArrayList();
	将泛型替换为具体类型的过程---泛型的擦除---发生在编译期

	能看懂泛型的通配符以及对应的泛型的继承