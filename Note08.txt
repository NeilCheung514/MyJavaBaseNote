复习:
	1.成员变量和局部变量:定义位置、作用范围、内存位置、生命周期
	2.构造方法:与类同名没有返回值类型的方法---在创建对象的时候,需要调用不同形式的构造方法---可以被重载
	3.this关键字---代表当前在活动的对象的引用---可以认为是一个虚拟对象,用于在类内调用本类的方法或者属性;this语句---this(),表示调用本类中对应形式的构造方法---必须放在构造函数首行
	4.代码块:构造代码块---在类内方法外用{}来定义---在创建对象的时候,先于构造方法执行,每创建一个对象都会执行一次;局部代码块---在方法内用{}定义的---限制变量的声明周期,从而提高内存的利用率
	5.面向对象的特征:封装、继承、多态
	6.封装的体现形式:方法(为了能够重复利用某段逻辑或者功能,将其进行提取,这种提取形式就是方法)、属性的私有化(将属性用private修饰,然后提供对外的操作或者读取的方法,可以在方法中对属性值做限定使之更加符合使用场景)、内部类---提高了代码的复用性/降低了代码的冗余度
	7.继承:extends---Java支持的是类鱼类之间的单继承;多继承和单继承的比较;---提高代码的复用性,保证调用的方法不会产生歧义
	8.super关键字:在子类中表示父类对象的引用---在调用父类中的方法或者属性的时候,需要通过父类对象来调用,super就表示这个隐含的父类对象---虚拟对象;super语句---定义在子类的构造函数中,表示调用父类对应形式的构造函数---子类的构造函数中都会直接或者间接的创建父类对象---super语句必须定义在构造函数首行
	9.权限修饰符:public > protected > 默认 > private ---明确子类中使用和子类对象使用不是一回事
	10.多态:编译时多态---方法的重载;运行时多态---向上造型、方法重写---基于继承;
			行为多态---方法的重载、方法的重写;对象多态---向上造型---父类声明,子类创建---父类定义行为的集合,子类实现行为的细节
	11.方法的重写:在父子类中方法签名一致的非静态方法---方法签名、返回值类型(基本类型和void必须一致)、权限修饰符、返回值类型(子类方法的返回值类型必须是父类或者父类的子类)

static---静态
	是一个修饰符---可以修饰变量、方法、内部类、代码块

静态变量
	用static修饰的变量称之为静态变量/类变量.在类加载的时候加载到了方法区中的静态区,并在静态区中自动的赋予了默认值.静态变量是先于对象存在的,所以它可以不通过对象而是通过类名来调用,也可以通过对象来调用,但是习惯上建议使用类名调用.这个类的每一个对象存储的是静态变量在静态区中的地址,所以这些对象是共享这个静态变量的.也因此,只要有一个对象对这个静态变量的值做了改变,其他对象获取的值也会改变---如果一些对象共享了某个特征,可以设置为静态的;如果每一个对象的某个属性各不一样,那么使用非静态的.
	类加载到了方法区中的静态常量池(存储类信息),类只加载一次,不再移除.除了核心类库以外,其他的类在第一次使用的时候才加载.

	静态变量不可以定义在方法中---静态变量随着类的加载而加载并初始化;方法在被调用的时候才执行.
	静态变量不可以定义在构造代码块中---静态变量随着类的加载而加载并初始化;构造代码块在对象被创建的时候执行

	注意:静态变量只能定义在类内,不可以定义在方法或者代码块中

静态方法
	用static修饰的方法称之为静态方法/类方法.随着类的加载而加载到方法区中的静态区,只存储在了静态区没有执行.在方法被调用的时候,到栈内存中执行.静态方法先于对象出现的,意味着可以通过类名来调用,也可以通过对象来调用的.

	静态方法可以重载

	静态方法可以被继承

	静态方法不可以被重写

	父子类中可以存在方法签名一致的静态方法---不构成重写---如果父子类中存在了方法签名一致的方法,要么都是静态方法,要么都是非静态方法

静态代码块
	用static修饰的代码块称之为静态代码块---只在类第一次加载的时候执行一次---只在类第一次真正使用(创建对象或者调用方法)的时候执行一次
	执行顺序:先加载父类---父类静态,然后加载子类---子类静态,其次创建父类对象---父类构造,最后创建子类---子类构造

final
	修饰数据、方法、类

常量
	final修饰的数据---常量---值不可改变---对于基本类型而言指的是实际值不可变,对于引用类型而言,指的是地址不可改变,而属性值可以改变

	修饰符的顺序不影响内存结构以及结果

最终方法
	final修饰的方法---最终方法---不能够被重写---能够被重载,能被继承
	考虑:在子类继承父类的时候,父类的什么对子类不可见?---被隐藏:private、代码块、构造函数
	注意:父类的所有的数据和方法子类都可以继承

最终类
	final修饰的类---最终类---不能被继承
	扩展:可以把一个类的构造方法私有化,这个类可以被继承吗?---可以(内部类)

	总结:
		1.在不考虑内部类的情况下,可以修饰类的修饰符:public、默认、final、abstract
		2.可以修饰方法的修饰符:权限修饰符、static、final、abstract、strictfp、
			synchronized、native

abstract
	如果子类对父类的某一个或者多个方法做了重写,父类中对应的方法没有定义方法体的必要,那么就可以省略这个方法的方法体,用abstract关键字把这个方法定义为抽象方法---抽象方法所在的类一定是抽象类,但是抽象类中不一定有抽象方法.
	抽象类不允许实例化(创建对象)---不能用Java代码实例化,底层是用C语言来构建的这个对象
	子类继承抽象类之后必须重写其中的抽象方法,除非这个子类本身也是抽象类

	抽象方法可以进行重载

	抽象方法不能用static修饰---static方法不能被重写,抽象方法必然被重写

	抽象方法不能用final修饰---final方法不能被重写,抽象方法必然被继承

	抽象方法不能用private修饰---private对子类不可见,无法重写

	抽象方法可以是默认的权限修饰符---要求父子类同包

	抽象方法所在的类一定是抽象类,一定不是最终类

接口
	用interface来定义接口,用implements关键字让接口和类产生联系,这种联系称之为实现
	接口不能实例化,也不能定义构造方法
	Java中支持单继承,多实现---类和类之间是单继承,类和接口之间是多实现的---
	多实现不能提高代码的复用性,反而导致实现的时候出现方法的混乱---接口不是为了提高复用性,而是为了统一方法结构,方便统一调用
	接口可以继承接口,而且是多继承
	在JDK1.7级以前,接口中只能定义抽象方法

	在接口中的属性默认是public static final修饰的